
<h2 id="AbstractLoggerWrapper">AbstractLoggerWrapper</h2>
<p>Implements an abstract converter from an XML line (child of loggers.{environment}) to a Logger instance @ LoggingAPI
</p>
<h3>Signature</h3>
<p>abstract class AbstractLoggerWrapper </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Calls children to return a \Lucinda\Logger instance from matching "logger" XML tag


            </td>
        </tr>
        <tr>
            <td>setLogger</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td><i>\Lucinda\Logging\Logger</i>
            </td>
            <td>
                Detects Logger instance based on XML tag supplied
. This method is: <ul><li>abstract</li><li>protected</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is invalid.</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If referenced resources do not exist.</li></ul>
            </td>
        </tr>
        <tr>
            <td>getLogger</td>
            <td>
            </td>
            <td><i>\Lucinda\Logging\Logger</i>
            </td>
            <td>
                Gets detected logger

            </td>
        </tr>
    </tbody>
</table>
<h2 id="Authentication">Authentication</h2>
<p>Performs user authentication based on mechanism chosen by developmer in XML (eg: from database via login form, from an oauth2 provider, etc)
</p>
<h3>Signature</h3>
<p>class Authentication </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $page,<br/><i>string</i> $contextPath,<br/><i><a href="#CsrfTokenDetector">CsrfTokenDetector</a></i> $csrfTokenDetector,<br/><i>\Lucinda\WebSecurity\PersistenceDriver[]</i> $persistenceDrivers
            </td>
            <td>
            </td>
            <td>
                Runs authentication logic.

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is invalid</li><li>throwing <a href="#SecurityPacket">SecurityPacket</a> If authentication encounters a situation where execution cannot continue and redirection is required</li></ul>
            </td>
        </tr>
        <tr>
            <td>getOAuth2Drivers</td>
            <td>
            </td>
            <td><i>array[string:OAuth2\Driver]</i>
            </td>
            <td>
                /*
Gets oauth2 drivers found (if authentication method was "oauth2")


            </td>
        </tr>
    </tbody>
</table>
<h2 id="AuthenticationWrapper">AuthenticationWrapper</h2>
<p>Defines an abstract authentication mechanism that works with AuthenticationResult
</p>
<h3>Signature</h3>
<p>abstract class AuthenticationWrapper </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setResult</td>
            <td><i>\Lucinda\WebSecurity\AuthenticationResult</i> $result,<br/><i>string</i> $sourcePage,<br/><i>string</i> $targetPage
            </td>
            <td>
            </td>
            <td>
                Sets authentication result.
. This method is: <ul><li>protected</li></ul>
            </td>
        </tr>
        <tr>
            <td>getResult</td>
            <td>
            </td>
            <td><i>\Lucinda\WebSecurity\AuthenticationResult</i>
            </td>
            <td>
                Gets authentication result.

            </td>
        </tr>
    </tbody>
</table>
<h2 id="Authorization">Authorization</h2>
<p>Performs request authorization based on mechanism chosen by developmer in XML (eg: from database)
</p>
<h3>Signature</h3>
<p>class Authorization </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $page,<br/><i>string</i> $contextPath,<br/><i>integer|string</i> $userID
            </td>
            <td>
            </td>
            <td>
                Runs authorization logic.
. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is invalid</li><li>throwing <a href="#SecurityPacket">SecurityPacket</a> If authorization encounters a situation where execution cannot continue and redirection is required</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="AuthorizationWrapper">AuthorizationWrapper</h2>
<p>Defines an abstract authorization mechanism that works with AuthenticationResult
</p>
<h3>Signature</h3>
<p>abstract class AuthorizationWrapper </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setResult</td>
            <td><i>\Lucinda\WebSecurity\AuthorizationResult</i> $result
            </td>
            <td>
            </td>
            <td>
                Sets result of authorization attempt.

. This method is: <ul><li>protected</li></ul>
            </td>
        </tr>
        <tr>
            <td>getResult</td>
            <td>
            </td>
            <td><i>\Lucinda\WebSecurity\AuthorizationResult</i>
            </td>
            <td>
                Gets result of authorization attempt


            </td>
        </tr>
    </tbody>
</table>
<h2 id="CacheableDriver">CacheableDriver</h2>
<p>Driver binding Servlets API and HTTP Caching API, fed with application and request information. Children have the responsibility
of implementing setters for etag and last modified time according to their specific business needs.
</p>
<h3>Signature</h3>
<p>abstract class CacheableDriver implements <a href="#\Lucinda\Caching\Cacheable">\Lucinda\Caching\Cacheable</a></p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\Lucinda\MVC\STDOUT\Application</i> $application,<br/><i>\Lucinda\MVC\STDOUT\Request</i> $request,<br/><i>\Lucinda\MVC\STDOUT\Response</i> $response
            </td>
            <td>
            </td>
            <td>
                Saves STDOUT MVC API objects for internal operations and calls children to set ETag and Last-Modified values.


            </td>
        </tr>
        <tr>
            <td>setTime</td>
            <td>
            </td>
            <td>
            </td>
            <td>
                Sets value of last modified time of requested resource
. This method is: <ul><li>abstract</li><li>protected</li></ul>
            </td>
        </tr>
        <tr>
            <td>getTime</td>
            <td>
            </td>
            <td>
            </td>
            <td>
                {@inheritDoc}
. This method is: <ul><li>overriding getTime() @ <a href="#\Lucinda\Caching\Cacheable">\Lucinda\Caching\Cacheable</a></li></ul>
            </td>
        </tr>
        <tr>
            <td>setEtag</td>
            <td>
            </td>
            <td>
            </td>
            <td>
                Sets value of etag matching requested resource
. This method is: <ul><li>abstract</li><li>protected</li></ul>
            </td>
        </tr>
        <tr>
            <td>getEtag</td>
            <td>
            </td>
            <td>
            </td>
            <td>
                {@inheritDoc}
. This method is: <ul><li>overriding getEtag() @ <a href="#\Lucinda\Caching\Cacheable">\Lucinda\Caching\Cacheable</a></li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="CachingBinder">CachingBinder</h2>
<p>Binds HTTP Caching API with MVC STDOUT API (aka Servlets API) in order to perform cache validation to a HTTP GET request and produce a response accordingly
</p>
<h3>Signature</h3>
<p>class CachingBinder </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\Lucinda\MVC\STDOUT\Application</i> $application,<br/><i>\Lucinda\MVC\STDOUT\Request</i> $request,<br/><i>\Lucinda\MVC\STDOUT\Response</i> $response
            </td>
            <td>
            </td>
            <td>
                Binds APIs to XML for HTTP cache validation

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If referenced resources in XML do not exist on disk or are invalid.</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="CachingPolicy">CachingPolicy</h2>
<p>Encapsulates basic HTTP caching policies rules.
</p>
<h3>Signature</h3>
<p>class CachingPolicy </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setCachingDisabled</td>
            <td><i>null|boolean</i> $value
            </td>
            <td>
            </td>
            <td>
                Sets caching as disabled


            </td>
        </tr>
        <tr>
            <td>getCachingDisabled</td>
            <td>
            </td>
            <td><i>null<br/>boolean</i>
            </td>
            <td>
                Checks whether or not caching is disabled.


            </td>
        </tr>
        <tr>
            <td>setExpirationPeriod</td>
            <td><i>null|integer</i> $expires
            </td>
            <td>
            </td>
            <td>
                Sets period from original server response by which entry expires in local (browser) cache.


            </td>
        </tr>
        <tr>
            <td>getExpirationPeriod</td>
            <td>
            </td>
            <td><i>null[<br/>integer</i>
            </td>
            <td>
                Gets period from original server response by which entry expires in local (browser) cache.


            </td>
        </tr>
        <tr>
            <td>setCacheableDriver</td>
            <td><i><a href="#CacheableDriver">CacheableDriver</a></i> $driver
            </td>
            <td>
            </td>
            <td>
                Sets driver that must be able to map requested resource to an ETAG/LAST-MODIFIED-DATE


            </td>
        </tr>
        <tr>
            <td>getCacheableDriver</td>
            <td>
            </td>
            <td><i><a href="#CacheableDriver">CacheableDriver</a></i>
            </td>
            <td>
                Gets driver that must be able to map requested resource to an ETAG/LAST-MODIFIED-DATE


            </td>
        </tr>
    </tbody>
</table>
<h2 id="CachingPolicyFinder">CachingPolicyFinder</h2>
<p>Encapsulates detection of caching policy from a relevant XML line.
</p>
<h3>Signature</h3>
<p>class CachingPolicyFinder </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>\Lucinda\MVC\STDOUT\Application</i> $application,<br/><i>\Lucinda\MVC\STDOUT\Request</i> $request,<br/><i>\Lucinda\MVC\STDOUT\Response</i> $response
            </td>
            <td>
            </td>
            <td>
                Detects caching policy from XML tag holding its definitions.


            </td>
        </tr>
        <tr>
            <td>getPolicy</td>
            <td>
            </td>
            <td><i><a href="#CachingPolicy">CachingPolicy</a></i>
            </td>
            <td>
                Gets detected caching policy


            </td>
        </tr>
    </tbody>
</table>
<h2 id="CachingPolicyLocator">CachingPolicyLocator</h2>
<p>Locates CachingPolicy in XML based on contents of http_caching tag. Binds route-based settings (if any) with
global caching settings into a CachingPolicy object.
</p>
<h3>Signature</h3>
<p>class CachingPolicyLocator </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\Lucinda\MVC\STDOUT\Application</i> $application,<br/><i>\Lucinda\MVC\STDOUT\Request</i> $request,<br/><i>\Lucinda\MVC\STDOUT\Response</i> $response
            </td>
            <td>
            </td>
            <td>
                CachingPolicyBinder constructor.

            </td>
        </tr>
        <tr>
            <td>getPolicy</td>
            <td>
            </td>
            <td><i><a href="#CachingPolicy">CachingPolicy</a></i>
            </td>
            <td>
                Gets detected caching policy

            </td>
        </tr>
    </tbody>
</table>
<h2 id="CsrfTokenDetector">CsrfTokenDetector</h2>
<p>Binds SynchronizerToken @ SECURITY-API with settings from configuration.xml @ SERVLETS-API  then sets up an object based on which one can perform
CSRF checks later on in application's lifecycle.
</p>
<h3>Signature</h3>
<p>class CsrfTokenDetector </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Creates an object

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If 'secret' key is not defined in XML</li></ul>
            </td>
        </tr>
        <tr>
            <td>generate</td>
            <td><i>mixed</i> $userID
            </td>
            <td><i>string</i>
            </td>
            <td>
                Encodes a token based on unique user identifier
. This method is: <ul><li>throwing <a href="#\Lucinda\WebSecurity\EncryptionException">\Lucinda\WebSecurity\EncryptionException</a> If encryption of token fails.</li></ul>
            </td>
        </tr>
        <tr>
            <td>isValid</td>
            <td><i>string</i> $token,<br/><i>mixed</i> $userID
            </td>
            <td><i>boolean</i>
            </td>
            <td>
                Checks if a token is valid for specific uuid.

. This method is: <ul><li>throwing <a href="#\Lucinda\WebSecurity\EncryptionException">\Lucinda\WebSecurity\EncryptionException</a> If decryption of token fails.</li><li>throwing <a href="#\Lucinda\WebSecurity\TokenException">\Lucinda\WebSecurity\TokenException</a> If token fails validations.</li><li>throwing <a href="#\Lucinda\WebSecurity\TokenRegenerationException">\Lucinda\WebSecurity\TokenRegenerationException</a> If token needs to be refreshed</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="DAOAuthenticationWrapper">DAOAuthenticationWrapper</h2>
<p>Binds DAOAuthentication @ SECURITY-API to settings from configuration.xml @ SERVLETS-API then performs login/logout if it matches paths @ xml via database.
</p>
<h3>Signature</h3>
<p>class DAOAuthenticationWrapper extends <a href="#AuthenticationWrapper">AuthenticationWrapper</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $currentPage,<br/><i>\Lucinda\WebSecurity\PersistenceDriver[]</i> $persistenceDrivers,<br/><i><a href="#CsrfTokenDetector">CsrfTokenDetector</a></i> $csrf
            </td>
            <td>
            </td>
            <td>
                Creates an object.

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li><li>throwing <a href="#\Lucinda\WebSecurity\AuthenticationException">\Lucinda\WebSecurity\AuthenticationException</a> If one or more persistence drivers are not instanceof PersistenceDriver</li><li>throwing <a href="#\Lucinda\WebSecurity\TokenException">\Lucinda\WebSecurity\TokenException</a> If CSRF checks fail</li><li>throwing <a href="#\Lucinda\SQL\ConnectionException">\Lucinda\SQL\ConnectionException</a> If connection to database server fails.</li><li>throwing <a href="#\Lucinda\SQL\StatementException">\Lucinda\SQL\StatementException</a> If query to database server fails.</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="DAOAuthorizationWrapper">DAOAuthorizationWrapper</h2>
<p>Binds DAOAuthorization @ SECURITY-API to settings from configuration.xml @ SERVLETS-API then performs request authorization via database.
</p>
<h3>Signature</h3>
<p>class DAOAuthorizationWrapper extends <a href="#AuthorizationWrapper">AuthorizationWrapper</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $currentPage,<br/><i>mixed</i> $userID
            </td>
            <td>
            </td>
            <td>
                Creates an object

. This method is: <ul><li>throwing <a href="#\Lucinda\SQL\ConnectionException">\Lucinda\SQL\ConnectionException</a> If connection to database server fails.</li><li>throwing <a href="#\Lucinda\SQL\StatementException">\Lucinda\SQL\StatementException</a> If query to database server fails.</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="DataSourceDetection">DataSourceDetection</h2>
<p>Encapsulates data source detection (itself encapsulating database server settings) from an XML tag
</p>
<h3>Signature</h3>
<p>abstract class DataSourceDetection </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $databaseInfo
            </td>
            <td>
            </td>
            <td>
                DataSourceDetection constructor.

            </td>
        </tr>
        <tr>
            <td>setDataSource</td>
            <td><i>\SimpleXMLElement</i> $databaseInfo
            </td>
            <td><i>mixed</i>
            </td>
            <td>
                Detects data source (itself encapsulating database server settings) from an XML tag
. This method is: <ul><li>abstract</li><li>protected</li></ul>
            </td>
        </tr>
        <tr>
            <td>getDataSource</td>
            <td>
            </td>
            <td><i>object</i>
            </td>
            <td>
                Gets detected data source

            </td>
        </tr>
    </tbody>
</table>
<h2 id="FormRequestValidator">FormRequestValidator</h2>
<p>Validates authentication requests in configuration.xml and encapsulates them into objects
</p>
<h3>Signature</h3>
<p>class FormRequestValidator </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Creates an object.
. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li></ul>
            </td>
        </tr>
        <tr>
            <td>login</td>
            <td><i>string</i> $currentPage
            </td>
            <td><i><a href="#LoginRequest|null">LoginRequest</a><br/>null</i>
            </td>
            <td>
                Sets up login data, if operation was requested

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If request doesn't come with mandatory parameters.</li></ul>
            </td>
        </tr>
        <tr>
            <td>logout</td>
            <td><i>string</i> $currentPage
            </td>
            <td><i><a href="#LogoutRequest|null">LogoutRequest</a><br/>null</i>
            </td>
            <td>
                Sets up logout data, if operation was requested
. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="IPDetector">IPDetector</h2>
<p>Detects client IP based on contents of $_SERVER superglobal
</p>
<h3>Signature</h3>
<p>class IPDetector </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td>
            </td>
            <td>
            </td>
            <td>
                Kick starts ip detection process

            </td>
        </tr>
        <tr>
            <td>getIP</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets detected client IP address


            </td>
        </tr>
    </tbody>
</table>
<h2 id="JsonWebTokenPersistenceDriverWrapper">JsonWebTokenPersistenceDriverWrapper</h2>
<p>Binds JsonWebTokenPersistenceDriver @ SECURITY API with settings from configuration.xml @ SERVLETS-API and sets up an object on which one can
forward json web token operations.
</p>
<h3>Signature</h3>
<p>class JsonWebTokenPersistenceDriverWrapper extends <a href="#PersistenceDriverWrapper">PersistenceDriverWrapper</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setDriver</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Sets up current persistence driver from XML into driver property.

. This method is: <ul><li>protected</li><li>overriding setDriver() @ <a href="#PersistenceDriverWrapper">PersistenceDriverWrapper</a></li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="LocaleDetector">LocaleDetector</h2>
<p>Detects locale based on contents of internationalization tag:

&lt;internationalization locale=&quot;en_US&quot; method=&quot;session&quot;&gt;&lt;/internationalization&gt;
</p>
<h3>Signature</h3>
<p>class LocaleDetector </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>\Lucinda\MVC\STDOUT\Request</i> $request
            </td>
            <td>
            </td>
            <td>
                Determines method to detect locale then performs locale detection by matching XML with client request/headers


            </td>
        </tr>
        <tr>
            <td>getDefaultLocale</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets application-generic locale detected from XML


            </td>
        </tr>
        <tr>
            <td>getDetectedLocale</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets locale requested by client detected by matching request to XML settings

            </td>
        </tr>
        <tr>
            <td>getDetectionMethod</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets locale detection method


            </td>
        </tr>
    </tbody>
</table>
<h2 id="LocalizationBinder">LocalizationBinder</h2>
<p>Binds Internationalization API with MVC STDOUT API (aka Servlets API) in order to be able to produce a localizable response via GETTEXT
</p>
<h3>Signature</h3>
<p>class LocalizationBinder </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\Lucinda\MVC\STDOUT\Application</i> $application,<br/><i>\Lucinda\MVC\STDOUT\Request</i> $request
            </td>
            <td>
            </td>
            <td>
                Sets up \Lucinda\Internationalization\Reader instance to use later on in automatic translation based on XML and client headers

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If referenced resources in XML do not exist on disk or are invalid.</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="LogReporter">LogReporter</h2>
<p>Binds STDERR MVC API to Logging API in order to report errors through loggers.
</p>
<h3>Signature</h3>
<p>abstract class LogReporter implements <a href="#\Lucinda\MVC\STDERR\ErrorReporter">\Lucinda\MVC\STDERR\ErrorReporter</a></p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Calls child to produce a Lucinda\Logger instance out of a "logger" XML tag


            </td>
        </tr>
        <tr>
            <td>getLogger</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td><i>\Lucinda\Logging\Logger</i>
            </td>
            <td>
                Detects logger based on XML attributes.

. This method is: <ul><li>abstract</li><li>protected</li></ul>
            </td>
        </tr>
        <tr>
            <td>report</td>
            <td><i></i> $request
            </td>
            <td>
            </td>
            <td>
                {@inheritDoc}
. This method is: <ul><li>overriding report() @ <a href="#\Lucinda\MVC\STDERR\ErrorReporter">\Lucinda\MVC\STDERR\ErrorReporter</a></li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="LoggingBinder">LoggingBinder</h2>
<p>Binds Logging API with MVC STDOUT API (aka Servlets API) in order to be able to log a message later on (eg: in a file or syslog)
</p>
<h3>Signature</h3>
<p>class LoggingBinder </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $developmentEnvironment
            </td>
            <td>
            </td>
            <td>
                Performs loggers detection based on XML and execution environment then aggregates results into a MultiLogger for cascading logs

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If referenced resources in XML do not exist on disk or are invalid.</li></ul>
            </td>
        </tr>
        <tr>
            <td>getLogger</td>
            <td>
            </td>
            <td><i><a href="#MultiLogger">MultiLogger</a></i>
            </td>
            <td>
                Gets detected logger


            </td>
        </tr>
    </tbody>
</table>
<h2 id="LoggingWrapper">LoggingWrapper</h2>
<p>Locates and instances loggers based on XML content.
</p>
<h3>Signature</h3>
<p>class LoggingWrapper </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $developmentEnvironment
            </td>
            <td>
            </td>
            <td>
                Reads XML tag loggers.{environment}, finds and saves loggers found.
. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is invalid.</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If pointed file doesn't exist or is invalid</li></ul>
            </td>
        </tr>
        <tr>
            <td>getLoggers</td>
            <td>
            </td>
            <td><i>\Lucinda\Logging\Logger[]</i>
            </td>
            <td>
                Gets detected logger.

            </td>
        </tr>
    </tbody>
</table>
<h2 id="LoginRequest">LoginRequest</h2>
<p>Encapsulates login request data. Inner class of FormRequestValidator!
</p>
<h3>Signature</h3>
<p>class LoginRequest </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setUsername</td>
            <td><i>string</i> $username
            </td>
            <td>
            </td>
            <td>
                Sets value of user name sent in login attempt.

            </td>
        </tr>
        <tr>
            <td>setPassword</td>
            <td><i>string</i> $password
            </td>
            <td>
            </td>
            <td>
                Sets value of user password sent in login attempt.

            </td>
        </tr>
        <tr>
            <td>setRememberMe</td>
            <td><i>boolean</i> $rememberMe
            </td>
            <td>
            </td>
            <td>
                Sets value of remember me option sent in login attempt (or null, if application doesn't support remember me)

            </td>
        </tr>
        <tr>
            <td>setSourcePage</td>
            <td><i>string</i> $sourcePage
            </td>
            <td>
            </td>
            <td>
                Sets current page.

            </td>
        </tr>
        <tr>
            <td>setDestinationPage</td>
            <td><i>string</i> $targetPage
            </td>
            <td>
            </td>
            <td>
                Sets page to redirect to on login/logout success/failure.

            </td>
        </tr>
        <tr>
            <td>getUsername</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets value of user name sent in login attempt.

            </td>
        </tr>
        <tr>
            <td>getPassword</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets value of user password sent in login attempt.

            </td>
        </tr>
        <tr>
            <td>getRememberMe</td>
            <td>
            </td>
            <td><i>boolean<br/>null</i>
            </td>
            <td>
                Gets value of remember me option sent in login attempt (or null, if application doesn't support remember me)

            </td>
        </tr>
        <tr>
            <td>getSourcePage</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets current page.

            </td>
        </tr>
        <tr>
            <td>getDestinationPage</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets page to redirect to on login/logout success/failure.

            </td>
        </tr>
    </tbody>
</table>
<h2 id="LogoutRequest">LogoutRequest</h2>
<p>Encapsulates logout request data. Inner class of FormRequestValidator!
</p>
<h3>Signature</h3>
<p>class LogoutRequest </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setSourcePage</td>
            <td><i>string</i> $sourcePage
            </td>
            <td>
            </td>
            <td>
                Sets current page.

            </td>
        </tr>
        <tr>
            <td>setDestinationPage</td>
            <td><i>string</i> $targetPage
            </td>
            <td>
            </td>
            <td>
                Sets page to redirect to on login/logout success/failure.

            </td>
        </tr>
        <tr>
            <td>getSourcePage</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets current page.

            </td>
        </tr>
        <tr>
            <td>getDestinationPage</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets page to redirect to on login/logout success/failure.

            </td>
        </tr>
    </tbody>
</table>
<h2 id="MultiLogger">MultiLogger</h2>
<p>Implements a logger that forwards internally to multiple loggers.
</p>
<h3>Signature</h3>
<p>class MultiLogger extends <a href="#\Lucinda\Logging\Logger">\Lucinda\Logging\Logger</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\Lucinda\Logging\Logger[]</i> $loggers
            </td>
            <td>
            </td>
            <td>
                Creates an object.


            </td>
        </tr>
        <tr>
            <td>log</td>
            <td><i></i> $info,<br/><i></i> $level
            </td>
            <td>
            </td>
            <td>
                {@inheritDoc}
. This method is: <ul><li>overriding log() @ <a href="#\Lucinda\Logging\Logger">\Lucinda\Logging\Logger</a></li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="NoSQLDataSourceBinder">NoSQLDataSourceBinder</h2>
<p>Binds NoSQL Data Access API with MVC STDOUT API (aka Servlets API) in order to detect a DataSource that will be automatically used later on when NoSQL server is queried
</p>
<h3>Signature</h3>
<p>class NoSQLDataSourceBinder </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $developmentEnvironment
            </td>
            <td>
            </td>
            <td>
                Binds NoSQL Data Access API to XML based on development environment and sets DataSource for later querying

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If referenced resources in XML do not exist on disk or are invalid.</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="NoSQLDataSourceDetection">NoSQLDataSourceDetection</h2>
<p>Encapsulates NoSQLDataSource detection (itself encapsulating database server settings) based on &lt;server&gt; XML tag contents
</p>
<h3>Signature</h3>
<p>class NoSQLDataSourceDetection extends <a href="#DataSourceDetection">DataSourceDetection</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setDataSource</td>
            <td><i>\SimpleXMLElement</i> $databaseInfo
            </td>
            <td><i>mixed</i>
            </td>
            <td>
                Detects data source (itself encapsulating database server settings) from an XML tag
. This method is: <ul><li>protected</li><li>overriding setDataSource() @ <a href="#DataSourceDetection">DataSourceDetection</a></li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="Oauth2AuthenticationWrapper">Oauth2AuthenticationWrapper</h2>
<p>Binds OAuth2Authentication @ SECURITY-API and Driver @ OAUTH2-CLIENT-API with settings from configuration.xml @ SERVLETS-API and vendor-specific
(eg: google / facebook) driver implementation, then performs login/logout if path requested matches paths @ xml.
</p>
<h3>Signature</h3>
<p>class Oauth2AuthenticationWrapper extends <a href="#AuthenticationWrapper">AuthenticationWrapper</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $currentPage,<br/><i>\Lucinda\WebSecurity\PersistenceDriver[]</i> $persistenceDrivers,<br/><i><a href="#CsrfTokenDetector">CsrfTokenDetector</a></i> $csrf
            </td>
            <td>
            </td>
            <td>
                Creates an object

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li><li>throwing <a href="#\Lucinda\WebSecurity\AuthenticationException">\Lucinda\WebSecurity\AuthenticationException</a> If one or more persistence drivers are not instanceof PersistenceDriver</li><li>throwing <a href="#\Lucinda\WebSecurity\TokenException">\Lucinda\WebSecurity\TokenException</a> If CSRF checks fail.</li><li>throwing <a href="#\Lucinda\SQL\ConnectionException">\Lucinda\SQL\ConnectionException</a> If connection to database server fails.</li><li>throwing <a href="#\Lucinda\SQL\StatementException">\Lucinda\SQL\StatementException</a> If query to database server fails.</li><li>throwing <a href="#\OAuth2\ClientException">\OAuth2\ClientException</a> When oauth2 local client sends malformed requests to oauth2 server.</li><li>throwing <a href="#\OAuth2\ServerException">\OAuth2\ServerException</a> When oauth2 remote server answers with an error.</li></ul>
            </td>
        </tr>
        <tr>
            <td>getDrivers</td>
            <td>
            </td>
            <td><i>array[string:OAuth2\Driver]</i>
            </td>
            <td>
                Gets OAuth2 drivers


            </td>
        </tr>
    </tbody>
</table>
<h2 id="PersistenceDriverWrapper">PersistenceDriverWrapper</h2>
<p>Defines an abstract persistence mechanism that works with PersistenceDriver objects.
</p>
<h3>Signature</h3>
<p>abstract class PersistenceDriverWrapper </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Creates an object.


            </td>
        </tr>
        <tr>
            <td>setDriver</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Sets up current persistence driver from XML into driver property.

. This method is: <ul><li>abstract</li><li>protected</li></ul>
            </td>
        </tr>
        <tr>
            <td>getDriver</td>
            <td>
            </td>
            <td><i>\Lucinda\WebSecurity\PersistenceDriver</i>
            </td>
            <td>
                Gets current persistence driver.


            </td>
        </tr>
    </tbody>
</table>
<h2 id="PersistenceDriversDetector">PersistenceDriversDetector</h2>
<p>Detects mechanisms for authenticated state persistence set in security.persistence XML tag.
</p>
<h3>Signature</h3>
<p>class PersistenceDriversDetector </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Sets persistence drivers based on contents of <persistence> XML tag.


            </td>
        </tr>
        <tr>
            <td>getPersistenceDrivers</td>
            <td>
            </td>
            <td><i>\Lucinda\WebSecurity\PersistenceDriver[]</i>
            </td>
            <td>
                Gets detected drivers for authenticated state persistence.


            </td>
        </tr>
    </tbody>
</table>
<h2 id="RememberMePersistenceDriverWrapper">RememberMePersistenceDriverWrapper</h2>
<p>Binds RememberMePersistenceDriver @ SECURITY API with settings from configuration.xml @ SERVLETS-API and sets up an object on which one can
forward remember-me cookie operations.
</p>
<h3>Signature</h3>
<p>class RememberMePersistenceDriverWrapper extends <a href="#PersistenceDriverWrapper">PersistenceDriverWrapper</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setDriver</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Sets up current persistence driver from XML into driver property.

. This method is: <ul><li>protected</li><li>overriding setDriver() @ <a href="#PersistenceDriverWrapper">PersistenceDriverWrapper</a></li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="SQLDataSourceBinder">SQLDataSourceBinder</h2>
<p>Binds SQL Data Access API with MVC STDOUT API (aka Servlets API) in order to detect a DataSource that will be automatically used later on when SQL server is queried
</p>
<h3>Signature</h3>
<p>class SQLDataSourceBinder </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $developmentEnvironment
            </td>
            <td>
            </td>
            <td>
                Binds SQL Data Access API to XML based on development environment and sets DataSource for later querying

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If referenced resources in XML do not exist on disk or are invalid.</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="SQLDataSourceDetection">SQLDataSourceDetection</h2>
<p>Encapsulates SQLDataSource detection (itself encapsulating database server settings) based on &lt;server&gt; XML tag contents
</p>
<h3>Signature</h3>
<p>class SQLDataSourceDetection extends <a href="#DataSourceDetection">DataSourceDetection</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setDataSource</td>
            <td><i>\SimpleXMLElement</i> $databaseInfo
            </td>
            <td><i>mixed</i>
            </td>
            <td>
                Detects data source (itself encapsulating database server settings) from an XML tag
. This method is: <ul><li>protected</li><li>overriding setDataSource() @ <a href="#DataSourceDetection">DataSourceDetection</a></li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="SecurityBinder">SecurityBinder</h2>
<p>Binds HTTP Security API &amp; OAuth2 Client API with MVC STDOUT API (aka Servlets API) in order to apply web security operations
(eg: authentication and authorization) on a routed request
</p>
<h3>Signature</h3>
<p>class SecurityBinder </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\Lucinda\MVC\STDOUT\Application</i> $application,<br/><i>\Lucinda\MVC\STDOUT\Request</i> $request
            </td>
            <td>
            </td>
            <td>
                Binds APIs based on XML to perform authentication/authorization on a request

. This method is: <ul><li>throwing <a href="#\Lucinda\SQL\ConnectionException">\Lucinda\SQL\ConnectionException</a> If connection to database server fails.</li><li>throwing <a href="#\Lucinda\SQL\StatementException">\Lucinda\SQL\StatementException</a> If query to database server fails.</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li><li>throwing <a href="#\Lucinda\WebSecurity\AuthenticationException">\Lucinda\WebSecurity\AuthenticationException</a> If one or more persistence drivers are not instanceof PersistenceDriver</li><li>throwing <a href="#\Lucinda\WebSecurity\TokenException">\Lucinda\WebSecurity\TokenException</a> If CSRF checks fail</li><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If request doesn't come with mandatory parameters.</li><li>throwing <a href="#\OAuth2\ClientException">\OAuth2\ClientException</a> When oauth2 local client sends malformed requests to oauth2 server.</li><li>throwing <a href="#\OAuth2\ServerException">\OAuth2\ServerException</a> When oauth2 remote server answers with an error.</li></ul>
            </td>
        </tr>
        <tr>
            <td>getUserID</td>
            <td>
            </td>
            <td><i>integer<br/>string</i>
            </td>
            <td>
                Gets detected logged in unique user identifier


            </td>
        </tr>
        <tr>
            <td>getCsrfToken</td>
            <td>
            </td>
            <td><i><a href="#CsrfTokenDetector">CsrfTokenDetector</a></i>
            </td>
            <td>
                Gets detected CSRF token generator / validator.


            </td>
        </tr>
        <tr>
            <td>getOAuth2Drivers</td>
            <td>
            </td>
            <td><i>array[string:OAuth2\Driver]</i>
            </td>
            <td>
                /*
Gets oauth2 drivers found (if authentication method was "oauth2")

            </td>
        </tr>
    </tbody>
</table>
<h2 id="SecurityPacket">SecurityPacket</h2>
<p>Holds information about authentication/authorization outcomes incompatible with continuing execution (requiring a redirection).
</p>
<h3>Signature</h3>
<p>class SecurityPacket extends <a href="http://php.net/manual/ro/class.exception.php" target="_blank">\Exception</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setCallback</td>
            <td><i>string</i> $callback
            </td>
            <td>
            </td>
            <td>
                Sets path to redirect to.


            </td>
        </tr>
        <tr>
            <td>getCallback</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets path to redirect to.


            </td>
        </tr>
        <tr>
            <td>setStatus</td>
            <td><i>integer</i> $status
            </td>
            <td>
            </td>
            <td>
                Sets redirection reason.


            </td>
        </tr>
        <tr>
            <td>getStatus</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets redirection reason.


            </td>
        </tr>
        <tr>
            <td>setAccessToken</td>
            <td><i>mixed</i> $userID,<br/><i>\Lucinda\WebSecurity\PersistenceDriver[]</i> $persistenceDrivers
            </td>
            <td>
            </td>
            <td>
                Sets access token (useful for stateless applications).


            </td>
        </tr>
        <tr>
            <td>getAccessToken</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets access token. In order to stay authenticated, each request will have to include this as a header.


            </td>
        </tr>
    </tbody>
</table>
<h2 id="SessionPersistenceDriverWrapper">SessionPersistenceDriverWrapper</h2>
<p>Binds SessionPersistenceDriver @ SECURITY API with settings from configuration.xml @ SERVLETS-API and sets up an object on which one can
forward session persistence operations.
</p>
<h3>Signature</h3>
<p>class SessionPersistenceDriverWrapper extends <a href="#PersistenceDriverWrapper">PersistenceDriverWrapper</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setDriver</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Sets up current persistence driver from XML into driver property.

. This method is: <ul><li>protected</li><li>overriding setDriver() @ <a href="#PersistenceDriverWrapper">PersistenceDriverWrapper</a></li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="SettingsDetector">SettingsDetector</h2>
<p>Binds Internationalization API Settings to &lt;internationalization&gt; tag content.
</p>
<h3>Signature</h3>
<p>class SettingsDetector </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i><a href="#LocaleDetector">LocaleDetector</a></i> $locale
            </td>
            <td>
            </td>
            <td>
                Saves detected internationalization settings based on contents of <internationalization> XML tag.


            </td>
        </tr>
        <tr>
            <td>getSettings</td>
            <td>
            </td>
            <td><i>\Lucinda\Internationalization\Settings</i>
            </td>
            <td>
                Gets compiled Internationalization API Settings object

            </td>
        </tr>
    </tbody>
</table>
<h2 id="SynchronizerTokenPersistenceDriverWrapper">SynchronizerTokenPersistenceDriverWrapper</h2>
<p>Binds SynchronizerTokenPersistenceDriver @ SECURITY API with settings from configuration.xml @ SERVLETS-API and sets up an object on which one can
forward synchronizer token operations.
</p>
<h3>Signature</h3>
<p>class SynchronizerTokenPersistenceDriverWrapper extends <a href="#PersistenceDriverWrapper">PersistenceDriverWrapper</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>setDriver</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Sets up current persistence driver from XML into driver property.

. This method is: <ul><li>protected</li><li>overriding setDriver() @ <a href="#PersistenceDriverWrapper">PersistenceDriverWrapper</a></li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="UserIdDetector">UserIdDetector</h2>
<p>Detects logged in unique user identifier from persistence drivers.
</p>
<h3>Signature</h3>
<p>class UserIdDetector </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\Lucinda\WebSecurity\PersistenceDriver[]</i> $persistenceDrivers
            </td>
            <td>
            </td>
            <td>
                Sets logged in user id based on persistence drivers


            </td>
        </tr>
        <tr>
            <td>getUserID</td>
            <td>
            </td>
            <td><i>integer<br/>string</i>
            </td>
            <td>
                Gets detected unique user identifier


            </td>
        </tr>
    </tbody>
</table>
<h2 id="ValidationBinder">ValidationBinder</h2>
<p>Binds Parameters Validation API with MVC STDOUT API (aka Servlets API) and stdout.xml in order to perform validation of path/request parameters
</p>
<h3>Signature</h3>
<p>class ValidationBinder </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\Lucinda\MVC\STDOUT\Request</i> $request
            </td>
            <td>
            </td>
            <td>
                Binds APIs to XML in order to perform request parameters validation based on contents of <route> tag.

. This method is: <ul><li>throwing <a href="#\Lucinda\RequestValidator\Exception">\Lucinda\RequestValidator\Exception</a> If XML is misconfigured</li><li>throwing <a href="#\Lucinda\RequestValidator\MethodNotSupportedException">\Lucinda\RequestValidator\MethodNotSupportedException</a> If http method used to retrieve resource is not supported.</li></ul>
            </td>
        </tr>
        <tr>
            <td>getResults</td>
            <td>
            </td>
            <td><i>\Lucinda\RequestValidator\ResultsList</i>
            </td>
            <td>
                Gets validation results


            </td>
        </tr>
    </tbody>
</table>
<h2 id="ViewLanguageBinder">ViewLanguageBinder</h2>
<p>Binds contents of &lt;application&gt; XML tag with detected environment then uses ViewLanguageAPI to produce a PHP file where templating logic in view
is compiled into PHP language.
</p>
<h3>Signature</h3>
<p>class ViewLanguageBinder </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $viewFile
            </td>
            <td>
            </td>
            <td>
                Compiles view file from ViewLanguage to PHP using also contents of <application> XML tag.

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is misconfigured</li><li>throwing <a href="#\Lucinda\Templating\ViewException">\Lucinda\Templating\ViewException</a> If compilation failed due to a developer error.</li></ul>
            </td>
        </tr>
        <tr>
            <td>getCompilationFile</td>
            <td>
            </td>
            <td><i>string</i>
            </td>
            <td>
                Gets compilation file path, where all ViewLanguage templating has been recursively compiled into PHP


            </td>
        </tr>
    </tbody>
</table>
<h2 id="XMLAuthenticationWrapper">XMLAuthenticationWrapper</h2>
<p>Binds XMLAuthentication @ SECURITY-API to settings from configuration.xml @ SERVLETS-API then performs login/logout if it matches paths @ xml via ACL @ XML.
</p>
<h3>Signature</h3>
<p>class XMLAuthenticationWrapper extends <a href="#AuthenticationWrapper">AuthenticationWrapper</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $currentPage,<br/><i>\Lucinda\WebSecurity\PersistenceDriver[]</i> $persistenceDrivers,<br/><i><a href="#CsrfTokenDetector">CsrfTokenDetector</a></i> $csrf
            </td>
            <td>
            </td>
            <td>
                Creates an object.
. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li><li>throwing <a href="#\Lucinda\WebSecurity\AuthenticationException">\Lucinda\WebSecurity\AuthenticationException</a> If one or more persistence drivers are not instanceof PersistenceDriver</li><li>throwing <a href="#\Lucinda\WebSecurity\TokenException">\Lucinda\WebSecurity\TokenException</a> If CSRF checks fail</li><li>throwing <a href="#\Lucinda\SQL\ConnectionException">\Lucinda\SQL\ConnectionException</a> If connection to database server fails.</li><li>throwing <a href="#\Lucinda\SQL\StatementException">\Lucinda\SQL\StatementException</a> If query to database server fails.</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="XMLAuthorizationWrapper">XMLAuthorizationWrapper</h2>
<p>Binds XMLAuthorization @ SECURITY-API to settings from configuration.xml @ SERVLETS-API then performs request authorization via contents of configuration.xml.
</p>
<h3>Signature</h3>
<p>class XMLAuthorizationWrapper extends <a href="#AuthorizationWrapper">AuthorizationWrapper</a> </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml,<br/><i>string</i> $currentPage,<br/><i>integer</i> $userID
            </td>
            <td>
            </td>
            <td>
                Creates an object.

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\XMLException">\Lucinda\MVC\STDOUT\XMLException</a> If XML is malformed.</li></ul>
            </td>
        </tr>
    </tbody>
</table>
<h2 id="XMLSessionSetup">XMLSessionSetup</h2>
<p>Sets up session options based on XML tag:
&lt;session expiration=&quot;10&quot; is_http_only=&quot;1&quot; is_https_only=&quot;1&quot; handler=&quot;{value}&quot; .../&gt;
Where:
to. Its file must be located in folder application/models.

<ul><li>expiration: (optional) seconds until session expires. If not set, session will expire as server-default.</li><li>is_http_only: (optional) whether or not to set session cookie as HttpOnly (can be 0 or 1; 0 is default).</li><li>is_https_only: (optional) whether or not to set session cookie as HTTPS only (can be 0 or 1; 0 is default).</li><li>handler: (optional) name of class implementing SessionHandlerInterface to which session handling will be delegated</li></ul></p>
<h3>Signature</h3>
<p>class XMLSessionSetup </p>
<h3>Methods</h3>
<table>
    <thead>
        <tr>
            <td>Method</td>
            <td>Arguments</td>
            <td>Returns</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>

        <tr>
            <td>__construct</td>
            <td><i>\SimpleXMLElement</i> $xml
            </td>
            <td>
            </td>
            <td>
                Sets up session for locale persistance across requests based on XML settings

. This method is: <ul><li>throwing <a href="#\Lucinda\MVC\STDOUT\ServletException">\Lucinda\MVC\STDOUT\ServletException</a> If handler file/class not found or latter is not instanceof SessionHandlerInterface</li></ul>
            </td>
        </tr>
        <tr>
            <td>getSecurityOptions</td>
            <td>
            </td>
            <td><i>\Lucinda\MVC\STDOUT\SessionSecurityOptions</i>
            </td>
            <td>
                Gets session security info.

            </td>
        </tr>
        <tr>
            <td>getHandler</td>
            <td>
            </td>
            <td><i>\SessionHandlerInterface</i>
            </td>
            <td>
                Gets instance of class to which session handling will be delegated to.

            </td>
        </tr>
    </tbody>
</table>